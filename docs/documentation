Research:

The first step I did was to find what projects already exist in the web. XcodeCoverage is the one that I found that was most similar to what we want to do.
https://github.com/jonreid/XcodeCoverage

But all this project was doing was writing a wrapper for LCOV. LCOV is another code coverage tool which is most widely used. It is written in Perl. I felt the best way to move forward would be to write a code similar to LCOV but additionally do the tasks that are needed by us.

With a little more research I found that instead of writing LCOV from scratch is would be enough to rewrite only some of its files. In particular "genhtml" is the only file that needs to be rewritten by us. "genhtml" is the piece of code in LCOV that actually generates the HTML files. Now the next step is to understand how "genhtml" actually does this.

"genhtml" actually parses the "infofile". "infofile" is another file created by LCOV. It is generated by the "geninfo" file of LCOV. It contains all the information that GCOV provides in a certain manner. We will look into the format in which the data is stored in the "infofile" shortly. GCOV is GCC's in-built code coverage tool that is used by LCOV. Basically LCOV is a wrapper around GCOV which provides beautified output.

Now let us look into the data stored in "infofile".

TN:<test name>

SF:<absolute path to the source file>

Following is a list of line numbers for each function name found in the
source file:

FN:<line number of function start>,<function name>

Next,  there  is  a  list  of  execution  counts  for each instrumented
function:

FNDA:<execution count>,<function name>

This list is followed by two lines containing the number  of  functions
found and hit:

FNF:<number of functions found>
FNH:<number of function hit>

Branch coverage information is stored which one line per branch:

BRDA:<line number>,<block number>,<branch number>,<taken>

Block  number  and  branch  number are gcc internal IDs for the branch.
Taken is either '-' if the basic block containing the branch was  never
executed or a number indicating how often that branch was taken.

Branch coverage summaries are stored in two lines:

BRF:<number of branches found>
BRH:<number of branches hit>

Then  there  is  a  list of execution counts for each instrumented line
(i.e. a line which resulted in executable code):

DA:<line number>,<execution count>[,<checksum>]

Note  that  there  may  be  an  optional  checksum  present  for   each
instrumented  line. The current geninfo implementation uses an MD5 hash
as checksumming algorithm.

At the end of a section, there is a summary about how many  lines  were
found and how many were actually instrumented:

LH:<number of lines with a non-zero execution count>
LF:<number of instrumented lines>

Each sections ends with:

end_of_record


What we actually do now is write our own file that parses the "infofile" and creates the HTML directory structure. Here directory structure basically means than we create a directory structure exactly like how it is in our code folder starting from the file "index.html".  

Code Organistion:

We divide the task our generating HTML output into two parts. First we generate JSON/XML output. Then we convert the JSON output into HTML output. Here we initally create a nested hash, with four levels of hashes. We convert this into a JSON file using the inbuilt .to_json method. We can also convert xml using the to_xml method. 

The second file that actually creates the HRML just parses the JSON file that we we made, and makes the directory structure.